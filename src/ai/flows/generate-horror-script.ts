// This is an autogenerated file from Firebase Studio.
"use server";

/**
 * @fileOverview A horror script generator AI agent supporting multiple languages.
 *
 * - generateHorrorScript - A function that handles the horror script generation process.
 * - GenerateHorrorScriptInput - The input type for the generateHorrorScript function.
 * - GenerateHorrorScriptOutput - The return type for the generateHorrorScript function.
 */

import { ai } from "@/ai/ai-instance";
import { z } from "genkit";

const MoodSchema = z.enum([
  "Psychological",
  "Supernatural",
  "Gore",
  "Thriller",
  "Paranormal Mystery",
]);

const LengthSchema = z.enum(["Short", "Medium", "Long"]);

const LanguageSchema = z
  .enum(["Hindi", "English", "Spanish", "French"])
  .describe("The language for the output script.");

const GenerateHorrorScriptInputSchema = z.object({
  mood: MoodSchema.describe(
    "The mood of the horror script. Allowed values: Psychological, Supernatural, Gore, Thriller, Paranormal Mystery."
  ),
  length: LengthSchema.describe(
    "The length of the horror script. Allowed values: Short, Medium, Long."
  ),
  language: LanguageSchema, // Added language field
  words: z.coerce
    .number()
    .int()
    .min(50)
    .max(5000)
    .describe("The number of words in the script."),
  referencePrompt: z
    .string()
    .optional()
    .describe(
      "An optional reference prompt or story idea to guide the script generation."
    ),
});
export type GenerateHorrorScriptInput = z.infer<
  typeof GenerateHorrorScriptInputSchema
>;

const GenerateHorrorScriptOutputSchema = z.object({
  script: z
    .string()
    .describe("The generated horror script in the specified language."),
});
export type GenerateHorrorScriptOutput = z.infer<
  typeof GenerateHorrorScriptOutputSchema
>;

export async function generateHorrorScript(
  input: GenerateHorrorScriptInput
): Promise<GenerateHorrorScriptOutput> {
  return generateHorrorScriptFlow(input);
}

const prompt = ai.definePrompt({
  name: "generateHorrorScriptPrompt",
  input: {
    schema: GenerateHorrorScriptInputSchema, // Use the updated schema here
  },
  output: {
    schema: GenerateHorrorScriptOutputSchema, // Use the updated schema here
  },
  prompt: `
  You are a professional horror storyteller known for creating immersive, cinematic narratives. Write a monologue-style horror story in {{language}} that feels like a haunting personal experience or a retelling of a terrifying tale. The story should match the following details:
    Mood: {{mood}}
    Length: {{length}}
    Word Count: {{words}}
    {{#if referencePrompt}} Inspiration Prompt: {{referencePrompt}}{{/if}}

    Instructions:
    The entire story must be in {{language}} with fluent, native-level storytelling tone. Write in a first-person monologue format, as if the narrator is speaking directly to the audience or recalling a traumatic memory. Use cinematic writing techniques — include vivid visual and sensory descriptions to create a movie-like experience. Do not include dialogues between characters. The narrator alone drives the story. Start with a strong hook that immediately grabs attention and builds suspense from the first sentence. Include cliffhangers, twists, and unexpected reveals to maintain fear and curiosity throughout. Integrate deep horror themes such as ghosts, cursed places, rituals, hallucinations, isolation, or supernatural forces. Focus on emotional and psychological depth — every scene should provoke tension, fear, and unease. 
    Avoid simple or low-quality plots. The story must feel layered, original, and chilling.

  Goal: Create a horror experience that feels like listening to a dark legend or a terrifying confession — immersive, terrifying, and unforgettable.
  `,
});

const generateHorrorScriptFlow = ai.defineFlow<
  typeof GenerateHorrorScriptInputSchema,
  typeof GenerateHorrorScriptOutputSchema
>(
  {
    name: "generateHorrorScriptFlow",
    inputSchema: GenerateHorrorScriptInputSchema,
    outputSchema: GenerateHorrorScriptOutputSchema,
  },
  async (input) => {
    const { output } = await prompt(input);
    return output!;
  }
);
